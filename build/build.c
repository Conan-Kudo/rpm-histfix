/* RPM - Copyright (C) 1995 Red Hat Software
 * 
 * build.c - routines for preparing and building the sources
 */

#include <stdlib.h>
#include <stdio.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <unistd.h>

#include "build.h"
#include "header.h"
#include "spec.h"
#include "specP.h"
#include "rpmerr.h"
#include "rpmlib.h"
#include "messages.h"
#include "stringbuf.h"
#include "var.h"
#include "pack.h"

struct Script {
    char *name;
    FILE *file;
};

struct Script *openScript(Spec spec);
void writeScript(struct Script *script, char *s);
int execScript(struct Script *script);
void freeScript(struct Script *script);
int execPart(Spec s, char *sb, char *name);

struct Script *openScript(Spec spec)
{
    struct Script *script = malloc(sizeof(struct Script));
    struct PackageRec *main_package = spec->packages;
    char *s;
    int_32 foo;

    if (! main_package) {
	error(RPMERR_INTERNAL, "Empty main package");
	exit(RPMERR_INTERNAL);
    }
    
    script->name = tempnam("/usr/tmp", "rpmbuild");
    script->file = fopen(script->name, "w");

    /* Prepare the script */
    fprintf(script->file,
	    "#!/bin/sh -e\n"
	    "# Script generated by rpm\n\n");

    if (isVerbose()) {
	fprintf(script->file, "set -x\n\n");
    } else {
	fprintf(script->file, "exec > /dev/null\n\n");
    }

    fprintf(script->file, "RPM_SOURCE_DIR=\"%s\"\n", getVar(RPMVAR_SOURCEDIR));
    fprintf(script->file, "RPM_BUILD_DIR=\"%s\"\n", getVar(RPMVAR_BUILDDIR));
    fprintf(script->file, "RPM_DOC_DIR=\"%s\"\n", getVar(RPMVAR_DOCDIR));
    fprintf(script->file, "RPM_OPT_FLAGS=\"%s\"\n", getVar(RPMVAR_OPTFLAGS));

    getEntry(main_package->header, RPMTAG_VERSION, &foo, (void **)&s, &foo);
    fprintf(script->file, "RPM_PACKAGE_VERSION=\"%s\"\n", s);
    getEntry(main_package->header, RPMTAG_RELEASE, &foo, (void **)&s, &foo);
    fprintf(script->file, "RPM_PACKAGE_RELEASE=\"%s\"\n", s);

    fprintf(script->file, "\ncd %s\n\n", getVar(RPMVAR_BUILDDIR));

    return script;
}

void writeScript(struct Script *script, char *s)
{
    fprintf(script->file, "%s", s);
}

int execScript(struct Script *script)
{
    int pid;
    int status;
    
    writeScript(script, "\nexit 0;\n");
    fclose(script->file);
    script->file = NULL;
    chmod(script->name, 0700);

    if (!(pid = fork())) {
	execl(script->name, script->name, NULL);
	error(RPMERR_SCRIPT, "Exec failed");
	exit(RPMERR_SCRIPT);
    }
    wait(&status);
    if (! WIFEXITED(status) || WEXITSTATUS(status)) {
	error(RPMERR_SCRIPT, "Bad exit status");
	exit(RPMERR_SCRIPT);
    }
    return 0;
}

void freeScript(struct Script *script)
{
    if (script->file)
	fclose(script->file);
    unlink(script->name);
    free(script->name);
    free(script);
}

int execPart(Spec s, char *sb, char *name)
{
    struct Script *script;

    script = openScript(s);
    writeScript(script, sb);
    execScript(script);
    freeScript(script);
    return 0;
}

int execPrep(Spec s)
{
    /* XXX Expand %setup and %patch macros here */
    return execPart(s, getStringBuf(s->prep), "%prep");
}

int execBuild(Spec s)
{
    return execPart(s, getStringBuf(s->build), "%build");
}

int execInstall(Spec s)
{
    return execPart(s, getStringBuf(s->install), "%install");
}

int execClean(Spec s)
{
    return execPart(s, getStringBuf(s->clean), "%clean");
}

int verifyList(Spec s)
{
    return 0;
}

int doBuild(Spec s, int flags)
{

    if (flags & RPMBUILD_LIST) {
	if (verifyList(s)) {
	    return 1;
	}
    }

    if (flags & RPMBUILD_PREP) {
	if (execPrep(s)) {
	    return 1;
	}
    }

    if (flags & RPMBUILD_BUILD) {
	if (execBuild(s)) {
	    return 1;
	}
    }

    if (flags & RPMBUILD_INSTALL) {
	if (execInstall(s)) {
	    return 1;
	}
    }

    if (flags & RPMBUILD_BINARY) {
	if (packageBinaries(s)) {
	    return 1;
	}
    }

    if (flags & RPMBUILD_SOURCE) {
	if (packageSource(s)) {
	    return 1;
	}
    }

    if (flags & RPMBUILD_CLEAN) {
	if (execClean(s)) {
	    return 1;
	}
    }

    return 0;
}
